## 十六进制与二进制，十进制转换(手动)

> 关于十六进制转成二进制:一个窍门是:记住十六进制的A对应十进制的10，以此类推到十六进制的F对应十进制的15.然后把十六进制的每一位用对应的十进制代替，再将十进制写成二进制，即为十六进制对应的二进制。

> 对于当一个十进制数是`2^n` n为整数时，可以把n表示成`i+4j` ,其中`0<=i<=3` ,那么这个十进制数可以直接写成对应的十六进制:` 0x2^i 后面+j个0 `.例如:十进制下:2的11次方，`n=11=3+4*2` ，可以直接写成十六进制:`0x800`.
>
> 而对于十六进制与十进制的转换,可以用短除法和乘法

| 十六进制 |  0   |  1   |  2   |  3   | 4    |  5   |  6   |  7   |  8   |  9   | A    |  B   |  C   |  D   |  E   |  F   |
| -------- | :--: | :--: | :--: | :--: | ---- | :--: | :--: | :--: | :--: | :--: | ---- | :--: | :--: | :--: | :--: | :--: |
| 十进制   |  0   |  1   |  2   |  3   | 4    |  5   |  6   |  7   |  8   |  9   | 10   |  11  |  12  |  13  |  14  |  15  |
| 二进制   | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |



## 两种顺序存储字节的方法

- 大端法:最高有效字节在最前面   (跟手写数字一样)
- 小端法:最低有效字节在最前面    (刚好相反)



## 布尔代数

对于**二进制表示**|**位向量**:`[01101001]` 来说，表示集合中含有的元素是`0,3,5,6`.使用这种编码集合的方法时，布尔运算`|` 对应集合的**并**,`&` 对应集合的**交**,`~` 对应集合的**补**.

> 对于十六进制数地位级运算，先将十六进制数的各个参数扩展成对应的二进制表示，然后再做二进制运算，最后转回十六进制。

## 逻辑运算

`||`,`&&`,`!`，对应命题逻辑的`OR`,`AND`,`NOT`.

逻辑运算认为所有非零参数都表示`true`,参数`0`则表示`FALSE`.

**短路效果**:对于逻辑运算，如果第一个参数就能确定表达式结果，就不会对之后的参数进行运算。

## 移位运算

- `x<<k`:左移`k`位,丢弃最高`k` 位,并在右端补`k`个`0`.从左往右可结合:`x<<k<<j==(x<<k)<<j`

- 逻辑右移:**Java** 用`x>>>k`:在左端补`k`个0.
- 算术右移:`x>>k`表示.在左端补`k`个最高有效位的值.

|      运算       |           值           |
| :-------------: | :--------------------: |
|        x        | [01100011]  [10010101] |
|      x<<4       | [00110000]  [01010000] |
| x>>>4(逻辑右移) | [00000110]  [00001001] |
| x>>4(算数右移)  | [00000110]  [11111001] |

> 移位运算的优先级比`+ -`运算低



## 整数表示
- 无符号数编码定义:\\(B2U_w(\overline x)=\sum_{i=0}^{w-1}x_i2^i\\)

- 补码编码定义:把无符号数的最高位变成符号位:即最高位的符号是`-`,其余位不变

处理同样字长的有符号数和无符号数之间的转换:数值可能改变，但位模式不变.

### 补码与无符号数的转换:

- T2U

    ![image-20230425174840570](https://raw.githubusercontent.com/Jiewyjson/P/main/md/v1/202304251748098.png)

- U2T

    ![image-20230425174913777](https://raw.githubusercontent.com/Jiewyjson/P/main/md/v1/202304251749508.png)

    > 一个运算中,如果一个运算数是有符号的，另一个数无符号的，`c`会隐式将无符号数转为有符号数，并且假设两个数都是非负的.

### 扩展位表示

- 无符号数的零扩展
- 补码数的符号扩展

### 截断

- 无符号数的截断
- 补码数的截断

### 运算

#### 整数

- 加法
    - 无符号加法
        - 正常 `x+y`
        - 正溢出 `x+y-(1<<w)`
    - 补码加法
        - 正溢出 `x+y-(1<<w)`
        - 正常 `x+y`
        - 负溢出 `x+y+(1<<w)`

> 检测无符号溢出:如果x+y的结果s<x||s<y
>
> 检测补码溢出:
>
> ​	1.正溢出,x>0,y>0但x+y的结果s<=0; 
>
> ​	2.负溢出:x<0,y<0但s>=0。



> 计算位级补码的非表示
>
> 一: 对每一位求补,再对结果+1
>
> 二: 设存在一位k(k是下标),k是最右边`1` 的位置,对k左边的所有位取反.



- 乘法
    - 无符号乘法: `(x*y)mod (1<<w)`
    - 补码乘法:
        - 首先跟无符号乘法一样先取模,然后计算无符号转换补码

> 2的幂:
>
> ​	`1<<k`: 表示`* 2的k次幂 `
>
> ​	`1>>k`: 表示`/ 2的k次幂`

无符号运算和补码运算乘以2的幂都可能会溢出，但是即便溢出，通过移位得到的结果是一样的。如`11` 的二进制4位`[1011]`,`11<<2=44`,即`[101100]`截断为4位`[1100]`十进制为`12`==`44 mod 16`







#### 浮点数

